var a = 1, b = 1, c, d;

c = ++a; alert(c); // 2
/* так как инкремент записан в префиксной форме, то для следующей операции(присваивания) 
будет использоваться новое значение(увеличенное на 1) "а" */

d = b++; alert(d); // 1 
/* так как инкремент записан в постфиксной форме, то для следующей операции(присваивания) 
будет использоваться старое значение значение "b" */

c = (2+ ++a); alert(c); // 5 
/* после строки №3 а = 2, приоритет у префиксной формы "++" выше чем у "+", поэтому сначала выполнится 
увеличение "а" на 1, затем, так как инкремент записан в префиксной форме, новое значение(3) передастся в качестве второго операнда в операцию сложения (2 + 3 = 5) */

d = (2+ b++); alert(d); // 4
/* после строки №7 b = 2, приоритет у постфиксной формы "++" выше чем у "+", поэтому сначала выполнится 
увеличение "b" на 1, но так как инкремент записан в постфиксной форме старое значение(23) передастся в качестве второго операнда в операцию сложения (2 + 2 = 4) */

alert(a); // 3
alert(b); // 3
/* В строке 11 и 15 выполнялась унарная операция инкремента и перед этим a = 2 и b = 2, значит при дальнейшем обращении к "а" и "b" мы будем получать значение 3 
ps говоря увеличение "а" на 1 я конечно же имею ввиду увеличение объекта на который ссылается "а"*/

-+!++NaN; //-1
/*так как все операции унарные выполнятся они будут по мере вычисления своих операндов, поэтому ++NaN = NaN, затем при операции логического NOT сгачала произойдёт преобразование типов NaN -> false 
и затем !false = true потом при выполнении операции унарного + произойдёт преобразование типов и true -> 1, и унарный минус поменяет знак числа 1 -> -1 */

+!+[]; //1
/*так как все операции унарные выполнятся они будут по мере вычисления своих операндов, поэтому при выполнении операции унарного + произойдёт преобразование типов и [] -> 0, 
затем при операции логического NOT сначала произойдёт преобразование типов 0 -> false и затем !false = true, потом при выполнении операции унарного + произойдёт преобразование типов true -> 1 */

!NaN+!NaN++; //2
/* операции по убыванию приоритета ++, !, +. Сначала выполнится операция инкремента: NaN++ даст NaN, затем при операции логического NOT для операндов NaN произойдёт преобразование типов NaN -> false 
и затем выполнится операция отрицания !false = true, и последняя операци сложения (true + true) сначала преобразует операнды к числовому типу, true -> 1 и выполнит сложение 1 + 1 = 2. */

var a = 2;
var x = 1 + (a *= 2);
/* Сначала выполнится операция в скобках и "a" будет равно 4, и дальше х = 1 + 4 = 5 Ответ: 5 */

/* Забегая немного вперед. Напишите программу, которая выводит через console.log все числа от 1 до 100, с двумя исключениями. 
Для чисел, нацело делящихся на 3, она должна выводить ‘Fizz’, а для чисел, делящихся на 5 (но не на 3) – ‘Buzz’.
Когда сумеете – исправьте её так, чтобы она выводила «FizzBuzz» для всех чисел, которые делятся и на 3 и на 5. */

(function a(num){
	for(i = 1;i <= num; i++) {
		
		if ((!(i % 3)) && (!(i % 5))){
			console.log('FizzBuzz');
		} else if (!(i % 3)){
			console.log('Fizz');
		} else if (!(i % 5)) {
			console.log('Buzz');
		} else {
			console.log(i);
		}
	}
})(100)
